// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module AddRawFN(
  input         io_subOp,
                io_a_isNaN,
                io_a_isInf,
                io_a_isZero,
                io_a_sign,
  input  [9:0]  io_a_sExp,
  input  [24:0] io_a_sig,
  input         io_b_isNaN,
                io_b_isInf,
                io_b_isZero,
                io_b_sign,
  input  [9:0]  io_b_sExp,
  input  [24:0] io_b_sig,
  output        io_invalidExc,
                io_rawOut_isNaN,
                io_rawOut_isInf,
                io_rawOut_isZero,
                io_rawOut_sign,
  output [9:0]  io_rawOut_sExp,
  output [26:0] io_rawOut_sig
);

  wire        effSignB = io_b_sign ^ io_subOp;	// @[AddRecFN.scala:60:30]
  wire        eqSigns = io_a_sign == effSignB;	// @[AddRecFN.scala:60:30, :61:29]
  wire [9:0]  _sDiffExps_T_1 = io_a_sExp - io_b_sExp;	// @[AddRecFN.scala:63:31]
  wire        _common_sExpOut_T = $signed(_sDiffExps_T_1) < 10'sh0;	// @[AddRecFN.scala:63:31, :64:41]
  wire [4:0]  modNatAlignDist = _common_sExpOut_T ? io_b_sExp[4:0] - io_a_sExp[4:0] : _sDiffExps_T_1[4:0];	// @[AddRecFN.scala:63:31, :64:{30,41,58}]
  wire        isMaxAlign = (|(_sDiffExps_T_1[9:5])) & (_sDiffExps_T_1[9:5] != 5'h1F | _sDiffExps_T_1[4:0] == 5'h0);	// @[AddRecFN.scala:63:31, :66:{19,37,45}, :67:{42,51,63,87}, :68:24]
  wire [4:0]  alignDist = isMaxAlign ? 5'h1F : modNatAlignDist;	// @[AddRecFN.scala:64:30, :66:45, :68:24]
  wire        closeSubMags = ~eqSigns & ~isMaxAlign & modNatAlignDist < 5'h2;	// @[AddRecFN.scala:61:29, :64:30, :66:45, :69:{24,36,48,68}]
  wire        _close_alignedSigA_T_5 = $signed(_sDiffExps_T_1) > -10'sh1;	// @[AddRecFN.scala:63:31, :73:18]
  wire [25:0] _close_alignedSigA_T_10 = _close_alignedSigA_T_5 & ~(_sDiffExps_T_1[0]) ? {io_a_sig, 1'h0} : 26'h0;	// @[AddRecFN.scala:63:31, :64:41, :73:{18,45}, :74:{12,32,35,58}]
  wire [26:0] _close_sSigSum_T_4 = ((_close_alignedSigA_T_5 & _sDiffExps_T_1[0] ? {io_a_sig, 2'h0} : 27'h0) | {1'h0, _close_alignedSigA_T_10[25], _close_alignedSigA_T_10[24:0] | (_common_sExpOut_T ? io_a_sig : 25'h0)}) - {io_b_sig[24], io_b_sig, 1'h0};	// @[AddRecFN.scala:63:31, :64:41, :73:{12,18,32,45,58}, :74:{12,68}, :75:12, :76:50]
  wire        _close_notTotalCancellation_signOut_T = $signed(_close_sSigSum_T_4) < 27'sh0;	// @[AddRecFN.scala:73:12, :76:50, :77:42]
  wire [25:0] close_sigSum = _close_notTotalCancellation_signOut_T ? 26'h0 - _close_sSigSum_T_4[25:0] : _close_sSigSum_T_4[25:0];	// @[AddRecFN.scala:64:41, :74:12, :76:50, :77:{27,42,49}]
  wire [3:0]  close_normDistReduced2 = (|(close_sigSum[25:24])) ? 4'h0 : (|(close_sigSum[23:22])) ? 4'h1 : (|(close_sigSum[21:20])) ? 4'h2 : (|(close_sigSum[19:18])) ? 4'h3 : (|(close_sigSum[17:16])) ? 4'h4 : (|(close_sigSum[15:14])) ? 4'h5 : (|(close_sigSum[13:12])) ? 4'h6 : (|(close_sigSum[11:10])) ? 4'h7 : (|(close_sigSum[9:8])) ? 4'h8 : (|(close_sigSum[7:6])) ? 4'h9 : (|(close_sigSum[5:4])) ? 4'hA : (|(close_sigSum[3:2])) ? 4'hB : 4'hC;	// @[AddRecFN.scala:77:{27,79}, Mux.scala:47:70, primitives.scala:104:{33,54}, :107:{15,57}]
  wire [56:0] _close_sigOut_T = {31'h0, close_sigSum} << {52'h0, close_normDistReduced2, 1'h0};	// @[AddRecFN.scala:64:41, :77:27, :82:38, Mux.scala:47:70]
  wire [23:0] far_sigSmaller = _common_sExpOut_T ? io_a_sig[23:0] : io_b_sig[23:0];	// @[AddRecFN.scala:64:41, :89:29]
  wire [28:0] far_mainAlignedSigSmaller = {far_sigSmaller, 5'h0} >> alignDist;	// @[AddRecFN.scala:66:37, :68:24, :89:29, :90:{52,56}]
  wire [8:0]  far_roundExtraMask_shift = $signed(9'sh100 >>> alignDist[4:2]);	// @[AddRecFN.scala:68:24, :92:47, primitives.scala:77:58]
  wire        _far_alignedSigSmaller_T_5 = (|(far_mainAlignedSigSmaller[2:0])) | (|({|(far_sigSmaller[23:22]), |(far_sigSmaller[21:18]), |(far_sigSmaller[17:14]), |(far_sigSmaller[13:10]), |(far_sigSmaller[9:6]), |(far_sigSmaller[5:2]), |(far_sigSmaller[1:0])} & {far_roundExtraMask_shift[1], far_roundExtraMask_shift[2], far_roundExtraMask_shift[3], far_roundExtraMask_shift[4], far_roundExtraMask_shift[5], far_roundExtraMask_shift[6], far_roundExtraMask_shift[7]}));	// @[AddRecFN.scala:89:29, :90:56, :95:{38,45,49,76,98}, Bitwise.scala:114:{18,47}, Cat.scala:33:92, primitives.scala:77:58, :79:22, :121:{33,54}, :124:{15,57}, :125:20]
  wire [27:0] far_sigSum = {1'h0, _common_sExpOut_T ? io_b_sig[23:0] : io_a_sig[23:0], 3'h0} + (eqSigns ? {1'h0, far_mainAlignedSigSmaller[28:3], _far_alignedSigSmaller_T_5} : {1'h1, ~{far_mainAlignedSigSmaller[28:3], _far_alignedSigSmaller_T_5}}) + {27'h0, ~eqSigns};	// @[AddRecFN.scala:61:29, :64:41, :67:42, :69:24, :73:12, :88:29, :90:56, :94:38, :95:{45,49}, :97:{39,62}, :98:{41,68}, Cat.scala:33:92]
  wire        notNaN_isInfOut = io_a_isInf | io_b_isInf;	// @[AddRecFN.scala:103:38]
  wire        addZeros = io_a_isZero & io_b_isZero;	// @[AddRecFN.scala:104:32]
  wire        notNaN_specialCase = notNaN_isInfOut | addZeros;	// @[AddRecFN.scala:103:38, :104:32, :105:46]
  assign io_invalidExc = io_a_isNaN & ~(io_a_sig[22]) | io_b_isNaN & ~(io_b_sig[22]) | io_a_isInf & io_b_isInf & ~eqSigns;	// @[AddRecFN.scala:61:29, :69:24, :102:57, :121:71, common.scala:82:{46,49,56}]
  assign io_rawOut_isNaN = io_a_isNaN | io_b_isNaN;	// @[AddRecFN.scala:125:35]
  assign io_rawOut_isInf = notNaN_isInfOut;	// @[AddRecFN.scala:103:38]
  assign io_rawOut_isZero = addZeros | ~notNaN_isInfOut & closeSubMags & ~(|(_close_sigOut_T[25:24]));	// @[AddRecFN.scala:69:48, :82:{38,63}, :83:{35,49,82}, :103:38, :104:32, :106:{37,41,74}]
  assign io_rawOut_sign = eqSigns & io_a_sign | io_a_isInf & io_a_sign | io_b_isInf & effSignB | ~notNaN_specialCase & closeSubMags & (|(_close_sigOut_T[25:24])) & (io_a_sign ^ _close_notTotalCancellation_signOut_T) | ~notNaN_specialCase & ~closeSubMags & (_common_sExpOut_T ? effSignB : io_a_sign);	// @[AddRecFN.scala:60:30, :61:29, :64:41, :69:48, :77:42, :82:{38,63}, :83:{49,82}, :84:56, :87:26, :105:46, :108:39, :109:39, :110:39, :112:10, :113:{38,77}, :114:{33,47}]
  assign io_rawOut_sExp = (closeSubMags | _common_sExpOut_T ? io_b_sExp : io_a_sExp) - {5'h0, closeSubMags ? {close_normDistReduced2, 1'h0} : {4'h0, ~eqSigns}};	// @[AddRecFN.scala:61:29, :64:41, :66:37, :69:{24,48}, :81:53, :116:{13,27}, :117:{13,18}, Mux.scala:47:70]
  assign io_rawOut_sig = closeSubMags ? {_close_sigOut_T[25:0], 1'h0} : eqSigns ? far_sigSum[27:1] | {26'h0, far_sigSum[0]} : far_sigSum[26:0];	// @[AddRecFN.scala:61:29, :64:41, :69:48, :74:12, :82:{38,63}, :98:68, :99:{25,62,67,79}, :118:28]
endmodule

